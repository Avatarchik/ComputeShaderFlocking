// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Node {

    float3 pos;
    float3 vel;
    float scale;
    float angle;
    float inc;
    float maxSpeed;
    float maxTurnSpeed;
    float3 targetPosition;
    float3 avoidPosition;
    float mass;

};

RWStructuredBuffer<Node> dataBuffer;


// steer toward a target in 3d space
float3 SeekTarget ( float3 boidPosition, float3 boidVelocity, float3 targetPosition, float maxSpeed, float maxTurnSpeed )
{

    float3 desiredVelocity = targetPosition - boidPosition;

    desiredVelocity = normalize(desiredVelocity) * maxSpeed;

    float3 turningForce = desiredVelocity - boidVelocity;
    if(length(turningForce) > maxTurnSpeed)
    {
        turningForce = normalize(turningForce) * maxTurnSpeed;
    }

    return turningForce;

}

float3 AvoidTarget ( float3 boidPosition, float3 boidVelocity, float3 avoidPosition, float maxSpeed, float maxTurnSpeed )
{

    float3 desiredVelocity = boidPosition - avoidPosition;

    desiredVelocity = normalize(desiredVelocity) * maxSpeed;

    float3 turningForce = desiredVelocity - boidVelocity;
    /*
    if(length(turningForce) > maxTurnSpeed)
    {
        turningForce = normalize(turningForce) * maxTurnSpeed;
    }
    */

    return turningForce;

}

[numthreads(96,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{

    Node node = dataBuffer[id.x];

    float3 accel = float3(0.0,0.0,0.0);

    if (length(node.avoidPosition-node.pos) > 4)
    {
        accel += SeekTarget( node.pos, node.vel, node.targetPosition, node.maxSpeed, node.maxTurnSpeed );
    }
    else
    {
        accel += AvoidTarget( node.pos, node.vel, node.avoidPosition, node.maxSpeed, node.maxTurnSpeed );
    }

    node.vel = node.vel + ( accel / node.mass);

    if(length(node.vel) > node.maxSpeed)
    {
        node.vel = normalize(node.vel) * node.maxSpeed;
    }


    //update position and keep within bounds
    //float3 newPos = node.pos + node.vel;

    //node.pos = newPos;

    node.pos += node.vel;

    dataBuffer[id.x] = node;

    //scaling
    /*
    //update sin value
    float angle = dataBuffer[id.x].angle + dataBuffer[id.x].inc;
    dataBuffer[id.x].angle = fmod(angle, 360);

    //update scale value
    float newScale = sin(radians(angle)) * 2;
    dataBuffer[id.x].scale = clamp(newScale, 0.1, 2);
    */

}
